{"version":3,"sources":["PathfindingVisualizer/Node/node.js","algorithms/dijkstra.js","PathfindingVisualizer/PathfindingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["Node","col","row","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","node","grid","unvisitedNeighbors","neighbors","push","length","filter","neighbor","isVisited","getUnvisitedNeighbors","previousNode","dijkstra","startNode","finishNode","visitedNodesInOrder","nodes","getAllNodes","closestNode","shift","Infinity","createNode","getNewGridWithWallToggled","newGrid","slice","newNode","PathfindingVisualizer","useState","setgrid","mouseisPressed","setmouseisPressed","useEffect","currentRow","getInitialGrid","animateShortestPath","nodesInShortestPathOrder","i","setTimeout","document","getElementById","visualizeDijkstra","console","log","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","onClick","window","location","reload","map","rowIdx","nodeIdx","mouseIsPressed","handleMouseDown","handleMouseEnter","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.5af807cd.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./node.css\";\r\n\r\nconst Node = ({\r\n  col,\r\n  row,\r\n  isFinish,\r\n  isStart,\r\n  isWall,\r\n  onMouseDown,\r\n  onMouseEnter,\r\n  onMouseUp,\r\n}) => {\r\n  const extraClassName = isFinish\r\n    ? \"node-finish\"\r\n    : isStart\r\n    ? \"node-start\"\r\n    : isWall\r\n    ? \"node-wall\"\r\n    : \"\";\r\n  return (\r\n    <div\r\n      id={`node-${row}-${col}`}\r\n      className={`node ${extraClassName}`}\r\n      onMouseDown={() => onMouseDown(row, col)}\r\n      onMouseEnter={() => onMouseEnter(row, col)}\r\n      onMouseUp={() => onMouseUp()}\r\n    ></div>\r\n  );\r\n};\r\n\r\nexport default Node;\r\n","function sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    if (closestNode.isWall) continue;\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n","import React, { useState, useEffect } from \"react\";\r\nimport Node from \"./Node/node\";\r\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\nconst START_NODE_ROW = 10;\r\nconst START_NODE_COL = 10;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 40;\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < 20; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < 50; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nconst PathfindingVisualizer = () => {\r\n  const [grid, setgrid] = useState([]);\r\n  const [mouseisPressed, setmouseisPressed] = useState(false);\r\n  useEffect(() => {\r\n    const grid = getInitialGrid();\r\n    setgrid(grid);\r\n  }, []);\r\n\r\n  const handleMouseDown = (row, col) => {\r\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\r\n    setgrid(newGrid);\r\n    setmouseisPressed(true);\r\n  };\r\n\r\n  const handleMouseEnter = (row, col) => {\r\n    if (!mouseisPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\r\n    setgrid(newGrid);\r\n  };\r\n\r\n  const handleMouseUp = () => {\r\n    setmouseisPressed(false);\r\n  };\r\n\r\n  const animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 10 * i);\r\n    }\r\n  };\r\n\r\n  const animateShortestPath = (nodesInShortestPathOrder) => {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n      }, 50 * i);\r\n    }\r\n  };\r\n\r\n  const visualizeDijkstra = () => {\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    console.log(visitedNodesInOrder);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  };\r\n\r\n  const clearGrid = () => {\r\n    window.location.reload(true);\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <nav className=\"navbar\">\r\n        <div>\r\n          <h1 className=\"title\">Path Finding Algorithm</h1>\r\n        </div>\r\n        <div>\r\n          <button className=\"button\" onClick={() => visualizeDijkstra()}>\r\n            Visualize Dijkstra's Algorithm\r\n          </button>\r\n          <button className=\"button\" onClick={() => clearGrid()}>\r\n            Clear the Grid\r\n          </button>\r\n        </div>\r\n      </nav>\r\n      <div className=\"grid\">\r\n        {grid.map((row, rowIdx) => {\r\n          return (\r\n            <div key={rowIdx}>\r\n              {row.map((node, nodeIdx) => {\r\n                const { row, col, isFinish, isStart, isWall } = node;\r\n                return (\r\n                  <Node\r\n                    key={nodeIdx}\r\n                    col={col}\r\n                    isFinish={isFinish}\r\n                    isStart={isStart}\r\n                    isWall={isWall}\r\n                    mouseIsPressed={mouseisPressed}\r\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\r\n                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\r\n                    onMouseUp={() => handleMouseUp()}\r\n                    row={row}\r\n                  />\r\n                );\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default PathfindingVisualizer;\r\n","import \"./App.css\";\nimport PathfindingVisualiser from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualiser />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}